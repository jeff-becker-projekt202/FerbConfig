<?php

declare(strict_types=1);

namespace Ferb\Conf\Providers;

use Ferb\Conf\ConfigSection;
use Ferb\Conf\Util\ConfigPath;
use Ferb\Iterators\FluentIterator;

abstract class ConfigProviderBase implements ConfigProviderInterface
{
    private $data;
    private $prefix;
    private $delimiter;

    protected function __construct($prefix = '', $delimiter = '')
    {
        $this->prefix = $prefix ?? '';
        $this->delimiter = $delimiter;

    }

    /**
     * gets a configuration value for the specified key.
     *
     * @return array [$success bool, $value mixed]
     */
    public function get(string $key): array
    {
        $this->ensure_data();
        if(isset($this->data[$key])){
            return [true, $this->data[$key]];
        }
        return [false, null];
    }

    /**
     * Returns the immediate descendant configuration keys for the given parent path
     * based on this provider's data and the set of keys returned by the preceeding
     * providers.
     *
     * @param array  $previous_keys keys generated by the preceeding providers
     * @param string $parent_path   the parent path
     *
     * @return array the child keys
     */
    public function get_child_keys(iterable $previous_keys, string $parent_path): iterable
    {

        $child_keys = $this->get_my_children($parent_path)
            ->append($previous_keys)
        ;

        return FluentIterator::from($child_keys)
            ->unique(function ($x, $y) {
                $x = $x instanceof ConfigSection ? $x->{$path}() : $x;
                $y = $y instanceof ConfigSection ? $y->{$path}() : $y;

                return \strcasecmp($x, $y);
            })
            ->order_by_asc(ConfigPath::compare_paths())
        ;
    }

    private function ensure_data(){
        if(!isset($this->data)){
            $this->data = $this->get_data();
        }
    }

    abstract protected function get_values(): array;

    protected function get_data(): array
    {
        $result = [];

        foreach ($this->get_values() as $key => $value) {
            $path = $this->normalize($key);
            if ($this->include($path)) {
                $result[$path] = $value;
            }
        }

        return $result;
    }

    protected function normalize($key): string
    {
        if (!empty($this->delimiter)) {
            $key = \str_replace($this->delimiter, ConfigPath::KeyDelimiter, $key);
        }

        return $key;
    }

    protected function include(string $key): bool
    {
        return empty($this->prefix) || 0 === stripos($key, $this->prefix);
    }

    protected static function flatten($arr)
    {
        $result = [];
        foreach ($arr as $key => $value) {
            if (is_array($value)) {
                foreach (self::flatten($value) as $child_key => $child_value) {
                    $path = ConfigPath::combine([$key, $child_key]);
                    $result[$path] = strval($child_value);
                }
            } else {
                $result[$key] = $value;
            }
        }

        return $result;
    }

    private function get_my_children($parent_path)
    {
        $this->ensure_data();
        $parent_path = trim($parent_path);
        $base = FluentIterator::from(array_keys($this->data));

        if (!empty($parent_path)) {
            $parent_path = $parent_path.ConfigPath::KeyDelimiter;
            $base = $base->filter(function ($key) use ($parent_path) {
                return 0 === stripos($key, $parent_path);
            });
        }

        $prefix_len = strlen($parent_path);
        $mine = $base->map(function ($key) use ($prefix_len) {
            $index = stripos($key, ConfigPath::KeyDelimiter, $prefix_len);
            if (false === $index) {
                return substr($key, $prefix_len);
            }

            return substr($key, $prefix_len, $index - $prefix_len);
        });

        return FluentIterator::from($mine);
    }
}
